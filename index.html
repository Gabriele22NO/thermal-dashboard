<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Dashboard Analisi Termica Produzione</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { background: #0e0e0e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; }
    header { background: #1a1a1a; padding: 1em; text-align: center; border-bottom: 2px solid #333; }
    h1 { margin: 0; color: #00d8ff; font-size: 1.8em; }
    main { display: flex; flex-wrap: wrap; padding: 1em; gap: 1em; }
    canvas { background: #222; border-radius: 10px; box-shadow: 0 0 10px #000; }
    section.stats, section.controls { flex: 1; min-width: 300px; padding: 1em; }
    section.controls { max-width: 450px; background: #1c1c1c; border-left: 2px solid #333; border-radius: 10px; }
    .btn { background: #005577; color: #fff; border: none; padding: 10px; margin: 5px 0; border-radius: 5px; cursor: pointer; width: 100%; font-weight: bold; }
    .btn:hover { background: #0077aa; }
    .highlight { color: #00ff99; font-weight: bold; }
    .alert { color: #ff4444; font-weight: bold; }
    label { display: block; margin-top: 1em; font-weight: bold; }
    input[type=number] { width: 100%; padding: 6px; margin-top: 5px; background: #222; border: 1px solid #555; color: #fff; border-radius: 5px; }
    ul { padding-left: 20px; }
  </style>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
$1
<body>
  <header><h1>📈 Analisi Termica Produzione - NEW OLEF</h1></header>
  <main>
    <section class="stats">
      <canvas id="chart" width="900" height="400"></canvas>
<div id="plotlyChart" style="display:none; width: 100%; height: 400px;"></div>
<select id="chartLibrary" onchange="toggleChartLibrary()" class="btn">
  <option value="chartjs" selected>📈 Chart.js</option>
  <option value="plotly">📊 Plotly</option>
</select>
    </section>
    <section class="controls">
      $1
      <label for="startTime">Ora Inizio (hh:mm)</label>
      <input type="time" id="startTime">
      <label for="endTime">Ora Fine (hh:mm)</label>
      <input type="time" id="endTime">
      <label for="cycleType">Tipo Ciclo</label>
      <select id="cycleType">
        <option value="all">Tutti</option>
        <option value="ok">Solo OK</option>
        <option value="scarto">Solo Scarti</option>
      </select>
      <label for="startDate">Data Inizio</label>
      <input type="date" id="startDate">
      <label for="endDate">Data Fine</label>
      <input type="date" id="endDate">
      <button class="btn" onclick="filterByDate()">📅 Filtra per Data</button>
      <label for="minTemp">Temperatura minima (°C)</label>
      <input type="number" id="minTemp" value="660">
      <label for="maxTemp">Temperatura massima (°C)</label>
      <input type="number" id="maxTemp" value="750">
      <label for="targetProd">Obiettivo produzione (pezzi / 24h)</label>
      <input type="number" id="targetProd" value="180">
      <button class="btn" onclick="applyThresholds()">📏 Applica Soglie</button>
      <button class="btn" onclick="resetZoom()">🔄 Reset Zoom</button>
      <button class="btn" onclick="exportCSV()">📤 Esporta CSV</button>
      <button class="btn" onclick="exportPDF()">🧾 Esporta Report PDF</button>
      <h2>📊 Statistiche</h2>
      <div id="summary"></div>
      <div id="turni"></div>
    </section>
    <section class="controls">
      <h2>📆 Trend Giornaliero</h2>
      <div id="dailyTrend"></div>
    </section>
  </main>
  <script>
    const url = 'https://docs.google.com/spreadsheets/d/1gNUrOS9Ibat2DtpINCAd_7ptcFk8-blRctzeK1Eyej0/gviz/tq?tqx=out:csv&sheet=Foglio1';
    const ctx = document.getElementById('chart').getContext('2d');
    let chart, csvData;

    function parseTurno(date) {
      const h = date.getHours();
      if (h >= 6 && h < 14) return 'Turno 1';
      if (h >= 14 && h < 22) return 'Turno 2';
      return 'Turno 3';
    }

    function smoothData(data, window = 34) {
      return data.map((_, i, arr) => {
        const slice = arr.slice(Math.max(0, i - window + 1), i + 1);
        return slice.reduce((sum, val) => sum + val, 0) / slice.length;
      });
    }

    let originalData = [];
    let times = [];
    let ciclo = [];

    function loadData() {
  // 🔒 Recupera filtri salvati se disponibili
  const savedFilters = JSON.parse(localStorage.getItem('dashboardFilters') || '{}');
  ["startDate", "endDate", "startTime", "endTime", "cycleType", "minTemp", "maxTemp", "targetProd", "chartLibrary"].forEach(id => {
    if (savedFilters[id] !== undefined && document.getElementById(id)) {
      document.getElementById(id).value = savedFilters[id];
    }
  });
  const startDate = document.getElementById('startDate')?.valueAsDate;
  const endDate = document.getElementById('endDate')?.valueAsDate;
  const startTime = document.getElementById('startTime')?.value;
  const endTime = document.getElementById('endTime')?.value;
  const filterType = document.getElementById('cycleType')?.value || 'all';

  Papa.parse(url, {
    download: true,
    header: true,
    complete: res => {
          csvData = res.data;
          let data = res.data.filter(r => r.Timestamp && r["Temp1 (°C)"]).map(r => {
  const [month, day, yearAndTime] = r.Timestamp.split('/');
  const [year, time] = yearAndTime.split(' ');
  const [hour, minute, second] = time.split(':');
  const iso = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${hour}:${minute}:${second}`;
  r._parsedDate = new Date(iso);
  return r;
});

          if (startDate || endDate || startTime || endTime) {
            data = data.filter(r => {
              const d = r._parsedDate;
              const timeStr = d.toTimeString().substring(0,5);
              const dateOk = (!startDate || d >= startDate) && (!endDate || d <= endDate);
              const timeOk = (!startTime || timeStr >= startTime) && (!endTime || timeStr <= endTime);
              return dateOk && timeOk;
            });
          }

          if (filterType !== 'all') {
            data = data.filter(r => r.Ciclo === filterType);
          }

          times = data.map(r => r._parsedDate);
          originalData = data.map(r => parseFloat(r["Temp1 (°C)"]));
          ciclo = data.map(r => r.Ciclo || "");

          updateChart();
    }
  });
          }

          times = data.map(r => new Date(r.Timestamp));
          originalData = data.map(r => parseFloat(r["Temp1 (°C)"]));
          ciclo = data.map(r => r.Ciclo || "");
        }
      });
    }

    function applyThresholds() {
      const min = parseFloat(document.getElementById('minTemp').value);
      const max = parseFloat(document.getElementById('maxTemp').value);
      updateChart(min, max);
    }

    function updateChart(minT = null, maxT = null) {
  const lib = document.getElementById('chartLibrary')?.value || 'chartjs';
  document.getElementById('chart').style.display = lib === 'chartjs' ? 'block' : 'none';
  document.getElementById('plotlyChart').style.display = lib === 'plotly' ? 'block' : 'none';
      renderDailyTrend();
      const smoothed = smoothData(originalData);
      const labels = times.map(t => t.toLocaleTimeString());
      const colors = ciclo.map((c, i) => {
        const val = originalData[i];
        if (c === "scarto") return "rgba(255,0,0,0.4)";
        if ((minT !== null && val < minT) || (maxT !== null && val > maxT)) return "rgba(255,165,0,0.4)";
        return "rgba(0,255,100,0.2)";
      });

      const points = ciclo.map(c => (c === "ok" ? 5 : 0));

      if (lib === 'chartjs') {
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: "Temperatura Smussata (°C)",
          data: smoothed,
          borderColor: "#00ffcc",
          backgroundColor: "rgba(0,255,200,0.05)",
          pointRadius: points,
          pointBackgroundColor: points.map(p => (p ? "yellow" : "transparent")),
          fill: true,
          segment: { backgroundColor: ctx => colors[ctx.p0DataIndex] }
        }]
      },
      options: {
        responsive: true,
        plugins: {
          zoom: {
            pan: { enabled: true, mode: 'x' },
            zoom: { wheel: { enabled: true }, mode: 'x' }
          },
          legend: { labels: { color: "#fff" } }
        },
        scales: {
          x: { ticks: { color: '#aaa' } },
          y: { ticks: { color: '#aaa' } }
        }
      }
    });
  } else {
    const plotlyTrace = {
      x: labels,
      y: smoothed,
      type: 'scatter',
      mode: 'lines+markers',
      marker: {
        color: points.map(p => (p ? 'yellow' : 'rgba(0,0,0,0)')),
        size: points
      },
      line: { color: '#00ffcc' },
      fill: 'tozeroy',
      fillcolor: 'rgba(0,255,200,0.1)'
    };
    const layout = {
      plot_bgcolor: '#222',
      paper_bgcolor: '#222',
      font: { color: '#eee' },
      margin: { t: 30, b: 40 },
      xaxis: { title: 'Orario' },
      yaxis: { title: 'Temp (°C)' }
    };
    Plotly.newPlot('plotlyChart', [plotlyTrace], layout);
  }
        }
      });

      const turni = { 'Turno 1': [], 'Turno 2': [], 'Turno 3': [] };
      let cicliTot = 0, scarti = 0;
      let prevOkTime = null;
      let lastCycleTime = null;
      const tcicli = [];
      const TEMP_DROP_THRESHOLD = 3;
      const turniData = { 'Turno 1': [], 'Turno 2': [], 'Turno 3': [] };

      let inCycle = false;
      let lastTemp = null;
      ciclo.forEach((c, i) => {
        const turno = parseTurno(times[i]);
        turni[turno].push(c);
        turniData[turno].push({ t: times[i], stato: c });

        const temp = originalData[i];
        if (!inCycle && c === "ok") {
          cicliTot++;
          if (prevOkTime) tcicli.push((times[i] - prevOkTime) / 60000);
          prevOkTime = times[i];
          inCycle = true;
          lastTemp = temp;
        } else if (inCycle && lastTemp !== null && temp < lastTemp - TEMP_DROP_THRESHOLD) {
          inCycle = false;
        }

        if (c === "scarto") scarti++;
      });
          }
        }
      });

      const tempo = (times[times.length - 1] - times[0]) / 3600000;
      const buoni = cicliTot - scarti;
      const obiettivo = parseInt(document.getElementById('targetProd').value) || 180;
      const atteso = Math.round(obiettivo * (tempo / 24));
      const efficienza = buoni / atteso * 100;
      const tcMedia = tcicli.length ? (tcicli.reduce((a, b) => a + b, 0) / tcicli.length) : 0;
      const deviazione = tcicli.length ? Math.sqrt(tcicli.reduce((a,b)=>a + Math.pow(b - tcMedia, 2), 0)/tcicli.length) : 0;
      const cicliAnomali = tcicli.filter(x => x > tcMedia * 1.5).length;

      document.getElementById("summary").innerHTML = `
        <p><b>Periodo:</b> ${tempo.toFixed(1)} h</p>
        <p><b>Prodotti:</b> ${cicliTot + scarti}, <b>Buoni:</b> ${buoni}, <b>Scarti:</b> ${scarti}</p>
        <p><b>Efficienza (su obiettivo ${atteso}):</b> ${efficienza.toFixed(1)}%</p>
        <p><b>Tempo ciclo medio:</b> ${tcMedia.toFixed(1)} min</p>
        <p><b>Deviazione standard tempo ciclo:</b> ${deviazione.toFixed(2)} min</p>
        <p><b>Cicli anomali:</b> ${cicliAnomali}</p>
      `;

      let best = null;
      const infoTurni = Object.entries(turniData).map(([k, arr]) => {
        const tempi = [];
        let prev = null, buoni = 0, scarti = 0;
        arr.forEach(e => {
          if (e.stato === "ok") {
            if (prev) tempi.push((e.t - prev) / 60000);
            prev = e.t;
            buoni++;
          } else {
            scarti++;
          }
        });
        const media = tempi.length ? tempi.reduce((a,b)=>a+b,0)/tempi.length : 0;
        const dev = tempi.length ? Math.sqrt(tempi.reduce((a,b)=>a+Math.pow(b-media,2),0)/tempi.length) : 0;
        const total = buoni + scarti;
        if (!best || buoni > best.buoni || (buoni === best.buoni && dev < best.dev)) best = { turno: k, buoni, dev };
        return `<li><b>${k}</b>: ${total} pezzi (${buoni} buoni, ${scarti} scarti) - ciclo medio: ${media.toFixed(1)} min, dev: ${dev.toFixed(2)}</li>`;
      }).join("\n");

      document.getElementById("turni").innerHTML = `
        <h3>Produzione per Turno</h3>
        <ul>${infoTurni}</ul>
        <p class="highlight">🔝 Turno migliore: <b>${best.turno}</b> (buoni: ${best.buoni}, dev std: ${best.dev.toFixed(2)} min)</p>
      `;
    }

    $1
window.toggleChartLibrary = function() {
  updateChart();
}

    function exportCSV() {
      const csv = Papa.unparse(csvData);
      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'dati_produzione.csv';
      a.click();
    }

    function exportPDF() {
  import('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js').then(jsPDF => {
    const { jsPDF: PDF } = jsPDF;
    const pdf = new PDF();
    pdf.text("Report Produzione - NEW OLEF", 10, 10);
    pdf.html(document.body, {
      x: 10,
      y: 20,
      callback: () => pdf.save('report_produzione.pdf')
    });
  });
}

    loadData();

    window.filterByDate = function() {
  const filtersToSave = {};
  ["startDate", "endDate", "startTime", "endTime", "cycleType", "minTemp", "maxTemp", "targetProd", "chartLibrary"].forEach(id => {
    const el = document.getElementById(id);
    if (el) filtersToSave[id] = el.value;
  });
  localStorage.setItem('dashboardFilters', JSON.stringify(filtersToSave));
  loadData();
}

    function renderDailyTrend() {
      if (!csvData) return;
      const daily = {};
      csvData.forEach(r => {
        if (!r.Timestamp || !r["Temp1 (°C)"] || !r.Ciclo) return;
        const date = new Date(r.Timestamp).toLocaleDateString("it-IT");
        if (!daily[date]) daily[date] = { total: 0, ok: 0, scarto: 0 };
        daily[date].total++;
        if (r.Ciclo === "ok") daily[date].ok++;
        if (r.Ciclo === "scarto") daily[date].scarto++;
      });
      const rows = Object.entries(daily).map(([date, d]) => {
        const eff = d.total ? ((d.ok - d.scarto) / d.total * 100).toFixed(1) : '0.0';
        return `<li><b>${date}</b>: ${d.total} pezzi, efficienza ${eff}%</li>`;
      }).join("
");
      document.getElementById("dailyTrend").innerHTML = `<ul>${rows}</ul>`;
    }
    function filterByDate() {
  loadData();
}
  </script>
</body>
</html>
